import { BaseAction } from './actions';
export declare class PathTrie<T> {
    private root;
    getOrCreatePathTrieNode(path: string[], nodeData?: T): PathTrieNode<T>;
    getPathTrieNode(path: string[]): PathTrieNode<T> | undefined;
    getPathTrie(path: string[]): PathTrie<T> | undefined;
    /**
     * If the callback returns false, it will not iterate into the children of the current node.
     */
    iterateBfs(callback: (data: T, path: string[]) => void | boolean): void;
    removeNode(path: string[]): void;
    clearNodeData(path: string[]): void;
    getNodeList(path: string[]): Array<PathTrieNode<T>>;
    private iterateInternal;
}
export declare class PathTrieNode<T> {
    children: Map<string, PathTrieNode<T>>;
    nodeData: T | undefined;
}
/**
 * Returns a trie which contains all the paths affected by the action. For
 * example, if the action contains a path action applied on path [A, B, C], then
 * [A], [A, B], [A, B, C] will be in the returned trie. Moreover, if
 * subscriptionTree is provided and contains [A, B, C, ...], then [A, B, C, ...]
 * will also be included in the returned trie.
 */
export declare function getPathTrieFromAction(action: BaseAction, subscriptionTree?: PathTrie<{}>): PathTrie<boolean>;
