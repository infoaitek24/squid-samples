import { DocTimestamp, LockManager, Mutation, SquidDocId, SquidDocument } from '@squidcloud/common';
import { DestructManager } from './destruct.manager';
import DocumentIdentityService from './document-identity.service';
import { DocumentStore } from './document-store';
import { MutationSender } from './mutation/mutation-sender';
import { QueryBuilderFactory } from './query/query-builder.factory';
import { QuerySubscriptionManager } from './query/query-subscription.manager';
import { SocketManagerInterface } from './socket.manager';
import { TransactionId } from './types';
export interface DocTimestampMetadata {
    timestamp: DocTimestamp;
    expireTimestamp?: number;
}
export declare class DataManager {
    private readonly documentStore;
    private readonly mutationSender;
    private readonly socketManager;
    private readonly querySubscriptionManager;
    private readonly queryBuilderFactory;
    private readonly lockManager;
    private readonly destructManager;
    private readonly documentIdentityService;
    private readonly docIdToLocalTimestamp;
    private currentTransactionId;
    /**
     * During a batch, any update to a document that may trigger an update to a query is collected here and once the batch
     * ends, the relevant subscribes to these queries will be updated.
     */
    private readonly batchClientRequestIds;
    /**
     * In this map we save timestamps for documents that are available locally or recently deleted but need to remain
     * here so if a mutation comes from the server we know whether to apply it or not based on the timestamp. For
     * example, if a document is removed locally and immediately after, an update is received from the server - In that
     * case, it may be the update pre-dates the data that was available locally a second ago. For that reason, the
     * timestamp needs to be kept and even for removed documents it will be kept for ~20 seconds more.
     *
     * Eventually, this map is used as a gatekeeper for preventing old versions of a document (based on timestamp) to
     * appear on the client.
     */
    private readonly docIdToServerTimestamp;
    /**
     * In the case of a local change (outgoing change) without a server timestamp, an incoming server update cannot be
     * applied and needs to be queued until the local state allows it. In this case the incoming update will be queued in
     * this map. Any future incoming server update to the same document will override the previous update in case it has
     * a later timestamp.
     */
    private readonly pendingIncomingUpdates;
    /**
     * A mutation sent to the server will be stored in this map until it receives a timestamp from the server. These
     * mutations were already applied locally and were sent to the server or about to be sent if sentToServer=false
     * (or are queued in the MutationSender due to a lock). The existence of these pending mutations indicates the data
     * manager to:
     * 1 - Not apply any incoming server mutation while there are outgoing mutations without a timestamp
     * 2 - Not delete the local document even if there are no queries related to this document - there is a chance
     *     that there will be a future query that will need this document and the query needs to return the local version
     *     of the document.
     * 3 - Even when all outgoing mutations have a timestamp, it may be that there is a pending query in flight that will
     *     need to return the document. In this case, the local document may be different from the server. Hence, it
     *     cannot accept the server change and will wait for another update from the server. For this purpose, timestamp
     *     will be stored in docsToTimestamp for ~20 more seconds.
     *
     * Note: Only one entry per squidDocId can be with sentToServer=false. This is true since all updates to the same doc
     *       in the same batch are appended (and reduced) to the same outgoing mutation object.
     */
    private readonly pendingOutgoingMutations;
    private readonly pendingOutgoingMutationsChanged;
    /**
     * A subject for whether there are outgoing mutations. If there are outgoing mutations, any incoming update from the
     * server will be delayed until all the outgoing mutations will be acknowledged by the server.
     * This mechanism is needed to avoid this case:
     *
     * collection.docRef('a').delete();
     * collection.snapshots().subscribe((res) => {
     *   // The result here may include doc with id='a' since the delete mutation was not acknowledged.
     * });
     *
     * If we wait for the acknowledgment message, we will have a server timestamp and will be able to ignore the incoming
     * result for document with id='a'.
     */
    private readonly outgoingMutationsEmpty;
    private readonly failedDocsToResync;
    private readonly refreshDocIdToTimestamp;
    private deleteExpiredTimestampsInterval;
    private handleIncomingMessagesForTests;
    constructor(documentStore: DocumentStore, mutationSender: MutationSender, socketManager: SocketManagerInterface, querySubscriptionManager: QuerySubscriptionManager, queryBuilderFactory: QueryBuilderFactory, lockManager: LockManager, destructManager: DestructManager, documentIdentityService: DocumentIdentityService);
    getProperties(squidDocId: SquidDocId): SquidDocument | undefined;
    /** Whether a document has changes that are out of sync with the server. */
    isDirty(squidDocId: SquidDocId): boolean;
    /**
     * Runs the provided function without sending mutations to the server while collecting the updates to the different
     * queries. Local updates will still be applied. Once the batch finishes, all the updates will be sent to the server
     * and the different queries will be notified. runInTransaction may be invoked inside another runInTransaction, only
     * the top level batch will trigger updates to the server.
     */
    runInTransaction(fn: (transactionId: TransactionId) => Promise<void>, transactionId?: TransactionId): Promise<void>;
    /** Applies a mutation done from the client (from DocumentReference) and sends it to the server. */
    applyOutgoingMutation(mutation: Mutation, transactionId: TransactionId | undefined): Promise<void>;
    /** Same as runInTransaction with the exception that the passed function runs synchronously. */
    private runInTransactionSync;
    /** Remove properties from the document record that should not be sent to the server. */
    private removeInternalProperties;
    /** Listens and handles mutations and snapshots notifications from the socketManager. */
    private handleNotifications;
    private handleIncomingMutations;
    private handleIncomingQuerySnapshots;
    /**
     * Returns a boolean for whether some updates were ignored because the client knows of a later timestamp for those
     * documents.
     */
    private applyIncomingUpdates;
    private addPendingIncomingUpdate;
    private maybeApplyIncomingUpdate;
    private destruct;
    private stopDeleteExpiredTimestampsJob;
    /**
     * Removes entries from the docToTimestamp map for all the documents that are no longer relevant for this client.
     * If a document is currently tracked, we forget it.
     * Cases a document is considered not relevant anymore:
     * 1 - There are no outgoing or incoming updates for this document AND:
     *   a - The document was deleted on the server and this client already received a notification about it OR
     *   b - The document no longer has a query that will keep it up-to-date
     */
    private startDeleteExpiredTimestampsJob;
    /**
     * Whether the document is tracked by any pending mutations or ongoing queries.
     */
    isTracked(squidDocId: string): boolean;
    /**
     * Whether a document exists locally, but is no longer tracked by any mutations or queries. This is often the case
     * for in-memory DocumentReferences that are not part of any query.
     */
    isForgotten(squidDocId: SquidDocId): boolean;
    /**
     * Whether a document only exists locally. This means that the document has never by sent to or received from the
     * server.
     */
    isLocalOnly(squidDocId: SquidDocId): boolean;
    /**
     * Whether the document has even been acknowledged by the server. Acknowledgements occur when an incoming query or
     * mutation is received, and when an outgoing mutation is acknowledged.
     */
    hasBeenAcknowledged(squidDocId: SquidDocId): boolean;
    /**
     * Updates the document with the new properties, returns true if an update was done or false in case the doc did not
     * change.
     */
    private updateDocumentFromSnapshot;
    private finishTransaction;
    private sendAllUnsentOutgoingMutations;
    private sendMutationsForIntegration;
    private removeOutgoingMutation;
    private resyncFailedUpdates;
    private refreshUpdatedDocuments;
    private groupOutgoingMutationsByIntegrationId;
    /**
     * Handles the case that due to some change (an incoming or outgoing change to a document), a document becomes orphan.
     * That is, there are no ongoing queries that will keep it up-to-date.
     * An orphan document should not stay locally since it may be stale after some time.
     */
    private handleOrphanDocs;
    private acknowledgeDocument;
    private setExpiration;
    private forgetDocument;
    private migrateDocIds;
    private hasPendingSentMutations;
}
