import { IntegrationId } from '../communication.types';
import { CollectionName, FieldName } from '../document.types';
import { AllOperators, ContextCondition, ContextConditions, FieldSort, GeneralCondition, GeneralConditions, GenericValue, Query } from '../query.types';
import { PartialBy, Paths } from '../types';
export declare class QueryContext<T = any> {
    readonly query: Query<T>;
    private readonly parsedConditions;
    constructor(query: Query<T>);
    get integrationId(): IntegrationId;
    get collectionName(): CollectionName;
    get limit(): number;
    sortedBy(sorts: Array<PartialBy<FieldSort<T>, 'asc'>>): boolean;
    sortedByExact(sorts: Array<PartialBy<FieldSort<T>, 'asc'>>): boolean;
    includes<F extends FieldName<T>, O extends AllOperators>(fieldName: F, operator: O, value: GenericValue<T, F, O>): boolean;
    includesCondition(condition: ContextCondition<T>): boolean;
    includesConditions(conditions: GeneralConditions<T>): boolean;
    matchesConditions(conditions: GeneralConditions<T>): boolean;
    matchesQuery(query: Query<T>): boolean;
    isSubsetOf<F extends FieldName<T>, O extends AllOperators>(fieldName: F, operator: O, value: GenericValue<T, F, O> | null): boolean;
    isSubsetOfCondition(condition: GeneralCondition<T>): boolean;
    isSubsetOfConditions(conditions: GeneralConditions<T>): boolean;
    isSubsetOfQuery(query: Query<T>): boolean;
    getConditionsFor<K extends FieldName<T>>(...fieldNames: K[]): ContextConditions<T, K>;
    getConditionsForField<K extends Paths<T>>(fieldName: K): ContextConditions<T>;
    /**
     * Compares a condition against a given operator and value to determine if the
     * provided condition is a subset of the operator and value. A condition is
     * considered a subset if all values that satisfy (return true for) the
     * condition also satisfy the operator and value.
     *
     * This is done using the underlying CompareTable, which provides a comparison
     * function for each operator pair, or undefined if the comparison would
     * always be false, regardless of the values.
     */
    private evaluateSubset;
    private evaluateIncludes;
    private parseConditions;
}
