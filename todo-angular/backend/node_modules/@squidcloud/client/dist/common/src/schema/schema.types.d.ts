import { JSONSchema } from 'json-schema-typed';
export type FieldPlaceholder = '__SQUID_SERVER_TIMESTAMP__' | '__SQUID_CLIENT_IP__' | '__SQUID_USER_ID__' | '__SQUID_API_KEY__';
export type BasicFieldType = 'string' | 'integer' | 'number' | 'boolean' | 'map' | 'array' | 'any';
export type CustomFieldType = 'date' | 'json';
export type SupportedFieldType = BasicFieldType | CustomFieldType;
export declare const SUPPORTED_FIELD_TYPES_ARRAY: Array<SupportedFieldType>;
type ConvertDeep<T extends JSONSchema> = Exclude<T, boolean> & {
    properties?: Record<string, ConvertDeep<JSONSchema>>;
    patternProperties?: Record<string, ConvertDeep<JSONSchema>>;
    nullable?: boolean;
    /**
     * The default value will be applied (default to 'empty'):
     * 'always' - no matter what the client sent, both on update and insert. In case of readOnly - applies only on insert.
     * 'empty' - only if the value of the filed is empty (undefined)
     * 'updateOrEmpty' - no matter what the client sent, updating the record will use the default value
     */
    applyDefaultValueOn?: 'always' | 'empty' | 'updateOrEmpty';
    isDate?: boolean;
    isJSON?: boolean;
    /**
     * Applies to the top level schema, a record in a nested object, or a regular property.
     * Basically, whether this property can participate in an insert mutation.
     */
    insertable?: boolean;
    /** Applies to the top level schema or a record in a nested object. */
    deletable?: boolean;
};
export type PropertySchema = ConvertDeep<JSONSchema>;
export type TopLevelPropertySchema = PropertySchema & {
    primaryKey?: boolean;
    /**
     * Whether the property is computed based on other properties or some formula.
     * If true, readonly also needs to be true and this field should not be part of an insert statement.
     */
    isComputed?: boolean;
    /**
     * Whether the default value generated by the database. CURRENT_DATE is something generated by the database vs
     * 'Hello' which is a constant.
     */
    isDefaultComputed?: boolean;
    /**
     * The database data type that is represented by this property. This is often different from the actual property
     * type, with is a Javascript primitive. For example, for a SMALLINT the dataType would be 'smallint', but the type
     * would be 'integer'.
     */
    dataType?: string;
};
export type CollectionSchema = ConvertDeep<JSONSchema> & {
    properties?: Record<string, TopLevelPropertySchema>;
};
export declare function compileSchema<S extends CollectionSchema>(schema: S): any;
export declare function validateSchema<S extends CollectionSchema>(schema: S, data: any, updatedPaths?: Array<string>, dataBefore?: any): void;
export declare function findMatchingPropertiesForKey<S extends CollectionSchema | PropertySchema>(schema: S, key: string): Array<PropertySchema>;
export {};
