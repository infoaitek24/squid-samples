"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const schema_types_1 = require("./schema.types");
const schema = {
    type: 'object',
    required: ['field1'],
    additionalProperties: false,
    properties: {
        field1: { type: 'string' },
        field2: { type: 'string', readOnly: true },
        field3: { type: 'array', items: { type: 'string' } },
        field4: {
            type: 'object',
            properties: {
                field4_1: { type: 'string' },
                field4_2: { type: 'string', readOnly: true },
            },
        },
        field5: {
            type: 'object',
            readOnly: true,
            properties: {
                field5_1: { type: 'string' },
                field5_2: { type: 'string' },
            },
        },
        field6: {
            type: 'object',
            isDate: true,
        },
        field7: {
            type: 'object',
            isDate: false,
        },
        field8: {
            type: 'string',
            primaryKey: true,
        },
        nonInsertable: {
            type: 'string',
            insertable: false,
        },
        nonInsertableRecord: {
            type: 'object',
            patternProperties: {
                '^.*$': {
                    insertable: false,
                    type: 'string',
                },
            },
        },
        nonDeletable: {
            type: 'string',
            deletable: false,
        },
        nonDeletableRecord: {
            type: 'object',
            patternProperties: {
                '^.*$': {
                    $ref: '#/definitions/record',
                    deletable: false,
                },
            },
        },
    },
    patternProperties: {
        '^field1[6-9]$': { type: 'string' },
    },
    definitions: {
        record: {
            type: 'string',
        },
    },
};
describe('Schema validation', () => {
    test('require field - pass', () => {
        expect(() => {
            (0, schema_types_1.validateSchema)(schema, { field1: 'some string' });
        }).not.toThrow();
    });
    test('pattern property - pass', () => {
        expect(() => {
            (0, schema_types_1.validateSchema)(schema, { field1: 'some string', field16: 'some string' });
        }).not.toThrow();
    });
    test('date property - pass', () => {
        expect(() => {
            (0, schema_types_1.validateSchema)(schema, { field1: 'some string', field6: new Date() });
        }).not.toThrow();
    });
    test('date property - fail', () => {
        expect(() => {
            (0, schema_types_1.validateSchema)(schema, { field1: 'some string', field6: {} });
        }).toThrow();
    });
    test('not date property - pass', () => {
        expect(() => {
            (0, schema_types_1.validateSchema)(schema, { field1: 'some string', field7: {} });
        }).not.toThrow();
    });
    test('not date property - fail', () => {
        expect(() => {
            (0, schema_types_1.validateSchema)(schema, { field1: 'some string', field7: new Date() });
        }).toThrow();
    });
    test('pattern property - wrong type', () => {
        expect(() => {
            (0, schema_types_1.validateSchema)(schema, { field1: 'some string', field16: 1 });
        }).toThrow();
    });
    test('pattern property - does not match', () => {
        expect(() => {
            (0, schema_types_1.validateSchema)(schema, { field1: 'some string', field20: 'ss' });
        }).toThrow();
    });
    test('require field - fail', () => {
        expect(() => {
            (0, schema_types_1.validateSchema)(schema, {});
        }).toThrow();
    });
    test('readonly constraint - insert', () => {
        expect(() => {
            (0, schema_types_1.validateSchema)(schema, { field1: 'some string', field2: 'long string' });
        }).not.toThrow();
    });
    test('readonly constraint - update', () => {
        expect(() => {
            (0, schema_types_1.validateSchema)(schema, { field1: 'some string', field2: 'long string' }, ['field2'], {
                field1: 'some string',
                field2: 'new long string',
            });
        }).toThrow(/field2/);
    });
    test('readonly constraint - nested', () => {
        expect(() => {
            (0, schema_types_1.validateSchema)(schema, { field1: 'some string', field4: { field4_2: 'text' } }, ['field4.field4_2'], {
                field1: 'some string',
                field4: { field4_2: 'new text' },
            });
        }).toThrow(/field4\.field4_2/);
    });
    test('update nested field', () => {
        expect(() => {
            (0, schema_types_1.validateSchema)(schema, { field1: 'some string', field4: { field4_1: 'text' } }, ['field4.field4_1']);
        }).not.toThrow();
    });
    test('readonly constraint - parent is readonly', () => {
        expect(() => {
            (0, schema_types_1.validateSchema)(schema, { field1: 'some string', field5: { field5_2: 'text' } }, ['field5.field5_2'], {
                field1: 'some string',
                field5: { field5_2: 'new text' },
            });
        }).toThrow(/field5/);
    });
    test('insertable constraint - top level', () => {
        expect(() => {
            (0, schema_types_1.validateSchema)(schema, { field1: 'some string', nonInsertable: 'data' }, []);
        }).toThrow(/insertable/);
    });
    test('insertable constraint - record', () => {
        expect(() => {
            (0, schema_types_1.validateSchema)(schema, {
                field1: 'some string',
                nonInsertableRecord: {
                    newRecord: 'data',
                },
            }, [], {
                field1: 'some string',
                nonInsertableRecord: {},
            });
        }).toThrow(/insertable/);
    });
    test('deletable constraint - top level', () => {
        expect(() => {
            (0, schema_types_1.validateSchema)(schema, { field1: 'some string' }, ['nonDeletable'], {
                field1: 'some string',
                nonDeletable: 'data',
            });
        }).toThrow(/deletable/);
    });
    test('deletable constraint - record', () => {
        expect(() => {
            (0, schema_types_1.validateSchema)(schema, {
                field1: 'some string',
                nonDeletableRecord: {},
            }, ['nonDeletableRecord', 'record'], {
                field1: 'some string',
                nonDeletableRecord: {
                    record: 'data',
                },
            });
        }).toThrow(/deletable/);
    });
});
//# sourceMappingURL=schema.types.spec.js.map