"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.findMatchingPropertiesForKey = exports.validateSchema = exports.compileSchema = exports.SUPPORTED_FIELD_TYPES_ARRAY = void 0;
const tslib_1 = require("tslib");
const ajv_1 = tslib_1.__importDefault(require("ajv"));
const ajv_formats_1 = tslib_1.__importDefault(require("ajv-formats"));
const deep_diff_1 = tslib_1.__importDefault(require("deep-diff"));
const http_status_enum_1 = require("../http-status.enum");
const assert_1 = require("../utils/assert");
const validation_1 = require("../utils/validation");
const ajv = new ajv_1.default({ allErrors: true, allowUnionTypes: false, useDefaults: false });
(0, ajv_formats_1.default)(ajv);
ajv.addKeyword({
    keyword: 'isDate',
    type: 'object',
    validate: (isDate, value) => {
        return isDate === value instanceof Date;
    },
});
ajv.addKeyword({
    keyword: 'isJSON',
    type: 'object',
    validate: (isJSON, value) => {
        try {
            const jsonString = JSON.stringify(value);
            JSON.parse(jsonString);
            return true;
        }
        catch (_a) {
            return false;
        }
    },
});
ajv.addKeyword({
    keyword: 'isComputed',
    validate: (isComputed, value) => {
        return isComputed ? value !== null : true;
    },
});
ajv.addKeyword({
    keyword: 'isDefaultComputed',
    validate: (isDefaultComputed, value) => {
        return isDefaultComputed ? value !== null : true;
    },
});
ajv.addKeyword({
    keyword: 'primaryKey',
    validate: (isPrimaryKey, value) => {
        return isPrimaryKey ? value !== null : true;
    },
});
ajv.addKeyword({
    keyword: 'insertable',
    validate: (insertable, value) => {
        return insertable ? value !== null : true;
    },
});
ajv.addKeyword({
    keyword: 'deletable',
    validate: (deletable, value) => {
        return deletable ? value !== null : true;
    },
});
ajv.addKeyword({
    keyword: 'applyDefaultValueOn',
    validate: (applyDefaultValueOn, value) => {
        return applyDefaultValueOn ? ['always', 'empty', 'updateOrEmpty'].includes(applyDefaultValueOn) : true;
    },
});
ajv.addKeyword({
    keyword: 'dataType',
    validate: (dataType, value) => {
        return true;
    },
});
exports.SUPPORTED_FIELD_TYPES_ARRAY = [
    'string',
    'integer',
    'number',
    'date',
    'boolean',
    'map',
    'array',
    'any',
];
function compileSchema(schema) {
    return ajv.compile(schema);
}
exports.compileSchema = compileSchema;
function validateSchema(schema, data, updatedPaths = [], dataBefore = {}) {
    const validator = compileSchema(schema);
    const isValid = validator(data);
    if (!updatedPaths.length && !isValid) {
        throw new validation_1.ValidationError(`The data does not conform with the collection schema.`, http_status_enum_1.HttpStatus.BAD_REQUEST, {
            errors: validator.errors,
        });
    }
    if (!isValid && updatedPaths.length) {
        for (const schemaError of (0, assert_1.truthy)(validator.errors)) {
            let fieldPath = schemaError.instancePath;
            if (schemaError.params['missingProperty']) {
                fieldPath = `${fieldPath}/${schemaError.params['missingProperty']}`;
            }
            fieldPath = fieldPath.slice(1).replace(/\//g, '.') + '.';
            if (updatedPaths.some((updatedPath) => fieldPath.startsWith(updatedPath + '.'))) {
                throw new validation_1.ValidationError(`${fieldPath} does not conform with the collection schema.`, http_status_enum_1.HttpStatus.BAD_REQUEST);
            }
        }
    }
    const diff = (0, assert_1.truthy)((0, deep_diff_1.default)(dataBefore, data));
    validateRestrictedFieldsForDiff(diff, schema, !!updatedPaths.length);
}
exports.validateSchema = validateSchema;
function validateRestrictedFieldsForDiff(diffs, schema, isUpdateMutation) {
    /** Check the top level change */
    if ((isUpdateMutation && schema.readOnly) || (schema.insertable === false && !isUpdateMutation)) {
        throw new validation_1.ValidationError(`The schema does not allow this action`, http_status_enum_1.HttpStatus.BAD_REQUEST);
    }
    for (const diff of diffs) {
        const path = (0, assert_1.truthy)(diff.path).join('.');
        const relevantProperties = getMatchingProperties((0, assert_1.truthy)(diff.path), schema);
        for (const property of relevantProperties.exactMatch) {
            if (property.readOnly && diff.kind === 'E') {
                throw new validation_1.ValidationError(`${path} is readonly`, http_status_enum_1.HttpStatus.BAD_REQUEST);
            }
            if (isUpdateMutation && property.deletable === false && diff.kind === 'D') {
                throw new validation_1.ValidationError(`${path} is not deletable`, http_status_enum_1.HttpStatus.BAD_REQUEST);
            }
            if (property.insertable === false && diff.kind === 'N') {
                throw new validation_1.ValidationError(`${path} is not insertable`, http_status_enum_1.HttpStatus.BAD_REQUEST);
            }
        }
        /** If a.b is readOnly and the update is done on a.b.c - The update should be rejected. */
        for (const property of relevantProperties.parentsMatch) {
            if (isUpdateMutation && property.readOnly) {
                throw new validation_1.ValidationError(`${path} is readonly`, http_status_enum_1.HttpStatus.BAD_REQUEST);
            }
        }
    }
}
function getMatchingProperties(path, schema) {
    const result = {
        exactMatch: [],
        parentsMatch: [],
    };
    if (!path.length) {
        result.exactMatch.push(schema);
        return result;
    }
    result.parentsMatch.push(schema);
    const pathToUse = [...path];
    while (pathToUse.length) {
        const key = (0, assert_1.notNullish)(pathToUse.shift());
        const matchingPropertiesForKey = findMatchingPropertiesForKey(schema, key);
        for (const property of matchingPropertiesForKey) {
            const subMatchingProperties = getMatchingProperties(pathToUse, property);
            result.parentsMatch.push(...subMatchingProperties.parentsMatch);
            result.exactMatch.push(...subMatchingProperties.exactMatch);
        }
    }
    return result;
}
function findMatchingPropertiesForKey(schema, key) {
    var _a, _b;
    const matchingProperties = ((_a = schema.properties) === null || _a === void 0 ? void 0 : _a[key]) ? [(_b = schema.properties) === null || _b === void 0 ? void 0 : _b[key]] : [];
    if (schema.patternProperties) {
        matchingProperties.push(...Object.entries(schema.patternProperties)
            .filter(([pattern]) => {
            return new RegExp(pattern).test(key);
        })
            .map(([_, matchedProperty]) => matchedProperty));
    }
    return matchingProperties;
}
exports.findMatchingPropertiesForKey = findMatchingPropertiesForKey;
//# sourceMappingURL=schema.types.js.map