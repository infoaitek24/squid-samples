"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseQuerySubscriptionId = exports.getQuerySubscriptionId = exports.compareOperator = exports.findQueriesForDocumentSync = exports.SimpleQueryMappingManager = exports.QueryMappingManager = void 0;
const nullish_1 = require("./utils/nullish");
const object_1 = require("./utils/object");
const serialization_1 = require("./utils/serialization");
class QueryMappingManager {
}
exports.QueryMappingManager = QueryMappingManager;
class SimpleQueryMappingManager extends QueryMappingManager {
    async findQueriesForDocument(appId, doc, collectionName, integrationId) {
        const mapping = await this.getMapping(appId, collectionName, integrationId);
        if (!mapping)
            return [];
        return findQueriesForDocumentSync(mapping, doc);
    }
}
exports.SimpleQueryMappingManager = SimpleQueryMappingManager;
function findQueriesForDocumentSync(mapping, doc) {
    var _a;
    // Adding all the unconditional mapped ids.
    const result = [...(mapping.unconditional || [])];
    const ignoredMappedId = new Set();
    // Mapping form query subscription id and the number of matched conditions for "doc".
    const mappedIdFoundMap = new Map();
    // Loop over all the fields that have conditions in some queries
    for (const [encodedFieldName, fieldMapping] of Object.entries(mapping.conditional || {})) {
        const fieldName = (0, serialization_1.decodeValueForMapping)(encodedFieldName);
        // For each field, loop over the operators
        for (const [operator, operatorMapping] of Object.entries(fieldMapping)) {
            // Find all the mappedId that match for "doc"
            const matchedMappedId = [];
            const valueInDocument = (_a = (0, object_1.getInPath)(doc, fieldName)) !== null && _a !== void 0 ? _a : null;
            const encodedValueInDocument = (0, serialization_1.encodeValueForMapping)(valueInDocument);
            switch (operator) {
                case '==': {
                    // The '==' operator is a special one since the same mappedId may appear in more
                    // than one value and if that is the case it should be treated as 'in' and should be counted only once since
                    // it is treated as an 'or'.
                    // Push all the mapped ids with the valueInDocument.
                    matchedMappedId.push(...(operatorMapping[encodedValueInDocument] || []));
                    break;
                }
                case '!=': {
                    // The '!=' operator is a special one since the same mappedId may appear in more
                    // than one value and if that is the case it should be treated as 'not in'.
                    const matchedSubscriptionIds = operatorMapping[encodedValueInDocument] || [];
                    // All the matchedSubscriptionIds cannot be part of the result.
                    matchedSubscriptionIds.forEach((qsi) => ignoredMappedId.add(qsi));
                    const restOfValues = Object.entries(operatorMapping).filter(([value]) => value !== encodedValueInDocument);
                    for (const [ignored, mappedId] of restOfValues) {
                        matchedMappedId.push(...mappedId);
                    }
                    break;
                }
                case '<':
                case '<=':
                case '>':
                case '>=': {
                    if ((0, nullish_1.isNotNullish)(valueInDocument)) {
                        matchedMappedId.push(...Object.entries(operatorMapping)
                            .filter(([conditionValue]) => compareOperator((0, serialization_1.decodeValueForMapping)(conditionValue), (0, serialization_1.recodeValue)(valueInDocument), operator))
                            .reduce((current, [ignored, matchedMappedId]) => {
                            current.push(...matchedMappedId);
                            return current;
                        }, []));
                    }
                    break;
                }
                default:
                    throw new Error('Unsupported operator: ' + operator);
            }
            // For each mapped id that was found, increment the counter by 1.
            for (const mappedId of matchedMappedId) {
                mappedIdFoundMap.set(mappedId, (mappedIdFoundMap.get(mappedId) || 0) + 1);
            }
        }
    }
    // The result includes all the mapped ids that have all the conditions matched.
    for (const [mappedId, matchCount] of mappedIdFoundMap.entries()) {
        if (ignoredMappedId.has(mappedId))
            continue;
        if (matchCount >= mapping.queriesMetadata[mappedId].condCount) {
            result.push(mappedId);
        }
    }
    return result;
}
exports.findQueriesForDocumentSync = findQueriesForDocumentSync;
function compareOperator(conditionValue, valueInDocument, operator) {
    if (conditionValue === null || valueInDocument === null)
        return false;
    switch (operator) {
        case '<':
            return valueInDocument < conditionValue;
        case '<=':
            return valueInDocument <= conditionValue;
        case '>':
            return valueInDocument > conditionValue;
        case '>=':
            return valueInDocument >= conditionValue;
        default:
            throw new Error(`Unsupported operator comparison: ${operator}`);
    }
}
exports.compareOperator = compareOperator;
/** Returns a unique identifier for the query which includes both the client id and the client request id. */
function getQuerySubscriptionId(clientId, clientRequestId) {
    return `${clientId}_${clientRequestId}`;
}
exports.getQuerySubscriptionId = getQuerySubscriptionId;
function parseQuerySubscriptionId(querySubscriptionId) {
    const splitString = querySubscriptionId.split('_');
    return {
        clientId: splitString[0],
        clientRequestId: splitString[1],
    };
}
exports.parseQuerySubscriptionId = parseQuerySubscriptionId;
//# sourceMappingURL=query.types.js.map