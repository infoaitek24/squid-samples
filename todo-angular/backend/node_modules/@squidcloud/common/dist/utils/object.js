"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.replaceKeyInRecord = exports.replaceKeyInMap = exports.deepReplace = exports.deleteInPath = exports.setInPath = exports.getInPath = void 0;
const tslib_1 = require("tslib");
const _ = tslib_1.__importStar(require("lodash"));
const assert_1 = require("./assert");
function getInPath(obj, path, delimiter = '.') {
    const splitPath = path.split(delimiter);
    let value = undefined;
    let currentObj = obj;
    while (currentObj && splitPath.length) {
        const key = (0, assert_1.truthy)(splitPath.shift());
        if (!(currentObj instanceof Object) || !(key in currentObj)) {
            return undefined;
        }
        value = currentObj[key];
        currentObj = value;
    }
    return value;
}
exports.getInPath = getInPath;
function isJsObject(obj) {
    if (typeof obj !== 'object')
        return false;
    return Reflect.getPrototypeOf(obj) === Object.prototype;
}
function setInPath(obj, path, value, delimiter = '.') {
    var _a;
    const splitPath = path.split(delimiter);
    let currentObj = obj;
    while (splitPath.length) {
        const key = (0, assert_1.truthy)(splitPath.shift());
        if (splitPath.length) {
            const newCurrentObj = isJsObject(currentObj[key]) ? (_a = _.clone(currentObj[key])) !== null && _a !== void 0 ? _a : {} : {};
            currentObj[key] = newCurrentObj;
            currentObj = newCurrentObj;
        }
        else {
            currentObj[key] = value;
        }
    }
}
exports.setInPath = setInPath;
function deleteInPath(obj, path, delimiter = '.') {
    var _a;
    const splitPath = path.split(delimiter);
    let currentObj = obj;
    while (splitPath.length) {
        const key = (0, assert_1.truthy)(splitPath.shift());
        if (splitPath.length) {
            const newCurrentObj = isJsObject(currentObj[key]) ? (_a = _.clone(currentObj[key])) !== null && _a !== void 0 ? _a : {} : {};
            currentObj[key] = newCurrentObj;
            currentObj = newCurrentObj;
        }
        else {
            delete currentObj[key];
        }
    }
}
exports.deleteInPath = deleteInPath;
function deepReplace(obj, keyName, replacer) {
    for (const key in obj) {
        if (key === keyName) {
            obj[key] = replacer(obj[key]);
        }
        else if (Array.isArray(obj[key])) {
            obj[key].forEach((member) => deepReplace(member, keyName, replacer));
        }
        else if (typeof obj[key] === 'object') {
            deepReplace(obj[key], keyName, replacer);
        }
    }
}
exports.deepReplace = deepReplace;
function replaceKeyInMap(map, a, b) {
    if (map.has(a)) {
        const value = map.get(a);
        map.delete(a);
        map.set(b, value);
    }
}
exports.replaceKeyInMap = replaceKeyInMap;
function replaceKeyInRecord(record, a, b) {
    const value = record[a];
    if (typeof value !== 'undefined') {
        record[b] = value;
        delete record[a];
    }
}
exports.replaceKeyInRecord = replaceKeyInRecord;
//# sourceMappingURL=object.js.map