"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.arrayMergeCustomizer = exports.asyncGroupBy = exports.removeSorted = exports.insertSorted = exports.binarySearch = void 0;
const lodash_1 = require("lodash");
function binarySearch(arr, key, comparator = (a, b) => (a > b ? 1 : a < b ? -1 : 0), low = 0, high = arr.length - 1) {
    if (high < low)
        return -1;
    const mid = Math.trunc((low + high) / 2);
    if (comparator(key, arr[mid]) === 0)
        return mid;
    if (comparator(key, arr[mid]) > 0)
        return binarySearch(arr, key, comparator, mid + 1, high);
    return binarySearch(arr, key, comparator, low, mid - 1);
}
exports.binarySearch = binarySearch;
function insertSorted(arr, key, comparator = (a, b) => (a > b ? 1 : a < b ? -1 : 0)) {
    const len = arr.length;
    let i;
    for (i = len - 1; i >= 0 && comparator(arr[i], key) > 0; i--)
        arr[i + 1] = arr[i];
    arr[i + 1] = key;
}
exports.insertSorted = insertSorted;
function removeSorted(arr, key, comparator = (a, b) => (a > b ? 1 : a < b ? -1 : 0)) {
    const index = binarySearch(arr, key, comparator);
    if (index > -1) {
        arr.splice(index, 1);
    }
}
exports.removeSorted = removeSorted;
async function asyncGroupBy(arr, groupNamer) {
    const groups = {};
    for (const element of arr) {
        const key = await groupNamer(element);
        if (!groups[key]) {
            groups[key] = [];
        }
        groups[key].push(element);
    }
    return groups;
}
exports.asyncGroupBy = asyncGroupBy;
const arrayMergeCustomizer = (a, b) => {
    if ((0, lodash_1.isArray)(a)) {
        return a.concat(b);
    }
    else {
        return undefined;
    }
};
exports.arrayMergeCustomizer = arrayMergeCustomizer;
//# sourceMappingURL=array.js.map