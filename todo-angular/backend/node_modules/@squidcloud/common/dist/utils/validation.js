"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.hasOnlyKeys = exports.isRightType = exports.isNotEmpty = exports.validateQueryLimit = exports.validateMutations = exports.validateOpenIdProviderType = exports.validateOpenIdProvider = exports.validateFieldSort = exports.ValidationError = void 0;
const assert_1 = require("./assert");
class ValidationError extends Error {
    constructor(error, statusCode, details) {
        super(error);
        this.statusCode = statusCode;
        this.details = details;
    }
}
exports.ValidationError = ValidationError;
function validatePathPart(part) {
    if (!part || !part.match(/^[a-zA-Z][a-zA-Z0-9!@#$%^&*~_]{0,49}$/)) {
        throw new Error('A document id and a collection id can contain only a-z, A-Z, 0-9,!@#$%^&*~_, starting' +
            'with a letter, at least one character, and up to 50.');
    }
}
function validateCollectionName(collectionName) {
    if (typeof collectionName !== 'string' || !collectionName) {
        throw new Error('Collection path has to be a non empty string');
    }
    validatePathPart(collectionName);
}
function validateFieldName(fieldName) {
    if (!fieldName || typeof fieldName !== 'string') {
        throw new Error('Field name has to be a non-empty string');
    }
    if (fieldName === '__docId__') {
        // __docId__ is the only valid fieldName that can start with '_'
        return;
    }
    if (!fieldName.match(/^[a-zA-Z][a-zA-Z0-9!@#$%^&*~_]{0,49}$/)) {
        throw new Error('A Field name can contain only a-z, A-Z, 0-9,!@#$%^&*~_, starting with a letter, at least one character, and up to 50. Field name: ' +
            fieldName);
    }
}
// TODO: remove if not used
function validateQueryCondition(condition) {
    if (!condition) {
        throw new Error('Condition cannot be empty');
    }
    if (!condition.operator || !['==', '!=', '>', '>=', '<', '<='].includes(condition.operator)) {
        throw new Error('Unsupported operator: ' + condition.operator);
    }
    validateFieldName(condition.fieldName);
    // TODO - figure out how to validate the value
}
function validateFieldSort(fieldSort) {
    if (!(fieldSort instanceof Object)) {
        throw new Error('Field sort has to be an object');
    }
    (0, assert_1.assertTruthy)(hasOnlyKeys(fieldSort, ['fieldName', 'asc']), 'Field sort should only contain a fieldName and asc');
    (0, assert_1.assertTruthy)(isRightType(fieldSort.asc, 'boolean'));
    validateFieldName(fieldSort.fieldName);
}
exports.validateFieldSort = validateFieldSort;
function validateOpenIdProvider(openIdProvider) {
    (0, assert_1.assertTruthy)(openIdProvider, 'INVALID_PROVIDER');
    validateOpenIdProviderType(openIdProvider.providerType);
    (0, assert_1.assertTruthy)(openIdProvider.providerType, 'INVALID_CLIENT_ID');
    (0, assert_1.assertTruthy)(openIdProvider.clientId, 'INVALID_CLIENT_ID');
    (0, assert_1.assertTruthy)(openIdProvider.domain, 'INVALID_DOMAIN');
    return openIdProvider;
}
exports.validateOpenIdProvider = validateOpenIdProvider;
function validateOpenIdProviderType(providerType) {
    const providerArray = ['auth0'];
    (0, assert_1.assertTruthy)(providerArray.includes(providerType), 'INVALID_OPEN_ID_PROVIDER_TYPE');
}
exports.validateOpenIdProviderType = validateOpenIdProviderType;
function validateDeleteMutation(mutation) {
    if (!mutation || mutation.type !== 'delete') {
        throw new Error('Mutation has to be non empty with type delete.');
    }
    // Not much to validate for delete.
}
function validateInsertMutation(mutation) {
    if (!mutation || mutation.type !== 'insert') {
        throw new Error('Mutation has to be non empty with type insert.');
    }
    if (!mutation.properties || typeof mutation.properties !== 'object') {
        throw new Error('The properties in insert mutation need to be a JSON object.');
    }
    for (const [fieldName] of Object.entries(mutation.properties)) {
        validateFieldName(fieldName);
        // TODO - figure out how to validate the value
    }
}
function validateUpdatePropertyMutation(propertyMutation) {
    if (!propertyMutation || propertyMutation.type !== 'update') {
        throw new Error('Update value property mutation has to be of type update');
    }
    if (propertyMutation.value === undefined) {
        throw new Error('Value has to exist in an update value property mutation..');
    }
}
function validateApplyNumericFnPropertyMutation(propertyMutation) {
    if (!propertyMutation || propertyMutation.type !== 'applyNumericFn') {
        throw new Error('Apply numeric fn mutation has to be of type applyNumericFn');
    }
    if (!['increment'].includes(propertyMutation.fn)) {
        throw new Error('Invalid fn for apply numeric fn.');
    }
    if (typeof propertyMutation.value !== 'number') {
        throw new Error('The value in an apply numeric fn function has to be numeric.');
    }
}
function validateApplyStringFnPropertyMutation(propertyMutation) {
    if (!propertyMutation || propertyMutation.type !== 'applyStringFn') {
        throw new Error('Apply string fn mutation has to be of type applyStringFn');
    }
    if (!['trim', 'extendString'].includes(propertyMutation.fn)) {
        throw new Error('Invalid fn for apply string fn.');
    }
    if (typeof propertyMutation.value !== 'string') {
        throw new Error('The value in an apply string fn function has to be a string.');
    }
}
function validatePropertyMutation(propertyMutation) {
    if (!propertyMutation || typeof propertyMutation !== 'object') {
        throw new Error('Property mutation need to be a JSON object.');
    }
    if (!['update', 'applyNumericFn', 'applyStringFn'].includes(propertyMutation.type)) {
        throw new Error(`Property mutation can be of type 'update', 'applyNumericFn', 'applyStringFn'`);
    }
    switch (propertyMutation.type) {
        case 'update':
            validateUpdatePropertyMutation(propertyMutation);
            break;
        case 'applyNumericFn':
            validateApplyNumericFnPropertyMutation(propertyMutation);
            break;
        case 'applyStringFn':
            validateApplyStringFnPropertyMutation(propertyMutation);
            break;
    }
}
function validateUpdateMutation(mutation) {
    if (!mutation || mutation.type !== 'update') {
        throw new Error('Mutation has to be non empty with type update.');
    }
    if (!mutation.properties || typeof mutation.properties !== 'object') {
        throw new Error('The properties in update mutation need to be a JSON object.');
    }
    const entries = Object.entries(mutation.properties);
    for (const [fieldName, propertyMutations] of entries) {
        validateFieldName(fieldName);
        for (const propertyMutation of propertyMutations) {
            validatePropertyMutation(propertyMutation);
        }
    }
}
function validateMutation(mutation) {
    if (!mutation) {
        throw new Error('Mutation cannot be empty');
    }
    if (!['insert', 'delete', 'update'].includes(mutation.type)) {
        throw new Error(`Mutation type has to be one of 'insert', 'delete', or 'update'`);
    }
    validateCollectionName(mutation.squidDocIdObj.collectionName);
    validatePathPart(mutation.squidDocIdObj.docId);
    switch (mutation.type) {
        case 'delete':
            validateDeleteMutation(mutation);
            break;
        case 'insert':
            validateInsertMutation(mutation);
            break;
        case 'update':
            validateUpdateMutation(mutation);
            break;
    }
}
function validateMutations(mutations) {
    if (!mutations || !(mutations instanceof Array) || !mutations.length) {
        throw new Error('The list of mutations has to be a non-empty array.');
    }
    for (const mutation of mutations) {
        validateMutation(mutation);
    }
}
exports.validateMutations = validateMutations;
function validateQueryLimit(limit) {
    (0, assert_1.assertTruthy)(isRightType(limit, 'number'));
    if (limit === -1)
        return;
    (0, assert_1.assertTruthy)(limit > 0, 'query limit has to be greater than 0');
    (0, assert_1.assertTruthy)(Math.floor(limit) === limit, 'query limit has to be an integer');
    (0, assert_1.assertTruthy)(limit <= 1000, 'Limit can be maximum 1000');
}
exports.validateQueryLimit = validateQueryLimit;
/** Returns true if the value is not an empty string (undefined/null are considered empty). */
function isNotEmpty(value) {
    validateCorrectStringType(value);
    return typeof value === 'string' && !!value;
}
exports.isNotEmpty = isNotEmpty;
/**
 * TODO: deprecated: this method is used in both validate...() and is...() methods.
 *  The validate...() must throw an error, while is...() must not.
 */
function validateCorrectStringType(value) {
    if (value !== null && value !== undefined && typeof value !== 'string') {
        throw new Error(`Unexpected input type ${typeof value}`);
    }
}
/** Returns true if 'typeof' of the 'value' is 'type' or 'type[]'. */
function isRightType(value, type) {
    // TODO: the method is ambiguous when the value is an empty array and will return 'true' for any type.
    if (Array.isArray(value)) {
        return value.every((element) => typeof element === type);
    }
    return typeof value === type;
}
exports.isRightType = isRightType;
/** Returns true if 'obj' has only keys listed in the 'keys'. Object can't be an array. */
function hasOnlyKeys(obj, keys) {
    return !Array.isArray(obj) && [...Object.keys(obj)].every((key) => keys.includes(key));
}
exports.hasOnlyKeys = hasOnlyKeys;
//# sourceMappingURL=validation.js.map