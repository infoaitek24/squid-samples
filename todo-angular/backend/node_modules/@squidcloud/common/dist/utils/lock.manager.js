"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LockManager = void 0;
const rxjs_1 = require("rxjs");
const assert_1 = require("./assert");
/**
 * A simple lock manager that locks a list of mutexes.
 * When locking a list of mutexes, the lock will start only when all the mutexes are available - preventing partial lock
 * and potential deadlocks.
 */
class LockManager {
    constructor() {
        this.locks = {};
    }
    async lock(...mutexes) {
        if (this.canGetLock(...mutexes)) {
            this.lockSync(...mutexes);
            return;
        }
        const relevantLocks = Object.entries(this.locks)
            .filter(([mutex]) => mutexes.includes(mutex))
            .map(([ignored, isLockedSubject]) => isLockedSubject);
        await (0, rxjs_1.lastValueFrom)((0, rxjs_1.combineLatest)(relevantLocks).pipe((0, rxjs_1.filter)((isLockedArray) => !isLockedArray.includes(true)), (0, rxjs_1.take)(1)));
        await this.lock(...mutexes);
    }
    release(...mutexes) {
        for (const mutex of mutexes) {
            const isLockedSubject = (0, assert_1.truthy)(this.locks[mutex]);
            isLockedSubject.next(false);
            isLockedSubject.complete();
            delete this.locks[mutex];
        }
    }
    canGetLock(...mutexes) {
        return !mutexes.some((mutex) => { var _a; return (_a = this.locks[mutex]) === null || _a === void 0 ? void 0 : _a.value; });
    }
    lockSync(...mutexes) {
        (0, assert_1.assertTruthy)(this.canGetLock(...mutexes));
        for (const mutex of mutexes) {
            this.locks[mutex] = new rxjs_1.BehaviorSubject(true);
        }
    }
}
exports.LockManager = LockManager;
//# sourceMappingURL=lock.manager.js.map