"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const object_1 = require("./object");
describe('Object util test', () => {
    describe('setInPath', () => {
        it('setInPath performs copy', () => {
            const obj = { a: 1, b: { c: 2 } };
            const copy = Object.assign({}, obj);
            (0, object_1.setInPath)(copy, 'b.c', 0);
            expect(obj.b.c).not.toBe(copy.b.c);
        });
        it('setInPath path does not exist', () => {
            const obj = { a: 1, b: { c: 2 } };
            (0, object_1.setInPath)(obj, 'd.e', 0);
            expect(obj.d.e).toBe(0);
        });
        it('setInPath override values', () => {
            const obj = { a: 1, b: { c: 2 } };
            (0, object_1.setInPath)(obj, 'b.c', 0);
            expect(obj.b.c).toBe(0);
        });
        it('setInPath single path', () => {
            const obj = { a: 1, b: { c: 2 } };
            (0, object_1.setInPath)(obj, 'a', 0);
            expect(obj.a).toBe(0);
        });
        it('setInPath over existing primitive path', () => {
            const obj = { a: 1, b: { c: 2 } };
            (0, object_1.setInPath)(obj, 'a.b', 0);
            expect(obj.a.b).toBe(0);
        });
    });
    describe('getInPath', () => {
        it('returns the right value (not nested)', () => {
            const obj = { a: 1, b: { c: 2 } };
            expect((0, object_1.getInPath)(obj, 'a')).toBe(1);
        });
        it('returns the right value (nested)', () => {
            const obj = { a: 1, b: { c: 2 } };
            expect((0, object_1.getInPath)(obj, 'b.c')).toBe(2);
        });
        it('returns undefined', () => {
            const obj = { a: 1, b: { c: 2 } };
            expect((0, object_1.getInPath)(obj, 'b.c.b')).toBeUndefined();
        });
    });
});
//# sourceMappingURL=object.spec.js.map