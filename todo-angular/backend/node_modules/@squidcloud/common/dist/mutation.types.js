"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.reduceMutations = exports.convertInsertToUpdate = exports.applyUpdateMutation = exports.mergeMutations = exports.sortUpdateMutationProperties = void 0;
const tslib_1 = require("tslib");
const _ = tslib_1.__importStar(require("lodash"));
const rxjs_1 = require("rxjs");
const assert_1 = require("./utils/assert");
const object_1 = require("./utils/object");
function applyStringFn(initialValue, propertyMutation) {
    switch (propertyMutation.fn) {
        case 'trim':
            if (typeof initialValue !== 'string')
                return initialValue;
            return initialValue.trim();
        case 'extendString':
            if (initialValue === null || initialValue === undefined)
                return propertyMutation.value;
            return initialValue + propertyMutation.value;
        default:
            throw new Error('Unknown string function: ' + JSON.stringify(propertyMutation));
    }
}
function applyNumericFn(initialValue, propertyMutation) {
    switch (propertyMutation.fn) {
        case 'increment':
            if (initialValue === null || initialValue === undefined)
                return propertyMutation.value;
            return initialValue + propertyMutation.value;
        default:
            throw new Error('Unknown numeric function: ' + JSON.stringify(propertyMutation));
    }
}
function applyPropertyMutation(property, propertyMutation) {
    switch (propertyMutation.type) {
        case 'applyNumericFn':
            return applyNumericFn(property, propertyMutation);
        case 'applyStringFn':
            return applyStringFn(property, propertyMutation);
        case 'update':
            return typeof propertyMutation.value === 'object' ? _.cloneDeep(propertyMutation.value) : propertyMutation.value;
        case 'removeProperty':
            return undefined;
        default:
            throw new Error('Unknown property mutation type: ' + JSON.stringify(propertyMutation));
    }
}
/**
 * Sorts the update mutation properties in the order the properties should be applied. If the update mutation has
 * updates for both 'a' and 'a.b', the update should be applied first to 'a' and then to 'a.b'.
 */
function sortUpdateMutationProperties(updateMutation) {
    return Object.entries(updateMutation.properties).sort(([propA], [propB]) => {
        const propADots = propA.split('.').length;
        const propBDots = propB.split('.').length;
        return propADots - propBDots;
    });
}
exports.sortUpdateMutationProperties = sortUpdateMutationProperties;
function mergeMutations(mutationA, mutationB) {
    if (mutationB.type === 'insert')
        return mutationB;
    if (mutationB.type === 'delete')
        return mutationB;
    // At this point mutationB.type has to be 'update'
    if (mutationA.type === 'delete')
        throw new Error('Cannot delete and then update');
    (0, assert_1.assertTruthy)(mutationB.type === 'update');
    if (mutationA.type === 'update')
        return mergeUpdateMutations(mutationA, mutationB);
    const result = _.cloneDeep(mutationA);
    for (const [fieldName, propertyMutationsAr] of sortUpdateMutationProperties(mutationB)) {
        const propertyMutations = propertyMutationsAr;
        for (const propertyMutation of propertyMutations) {
            const value = applyPropertyMutation((0, object_1.getInPath)(result.properties, fieldName), propertyMutation);
            if (value === undefined) {
                (0, object_1.deleteInPath)(result.properties, fieldName);
            }
            else {
                (0, object_1.setInPath)(result.properties, fieldName, value);
            }
        }
    }
    return result;
}
exports.mergeMutations = mergeMutations;
function mergeUpdateMutations(mutationA, mutationB) {
    const result = _.cloneDeep(mutationA);
    mutationB = _.cloneDeep(mutationB);
    for (const [aPropName] of sortUpdateMutationProperties(result)) {
        const aPropNameDots = aPropName.split('.').length;
        const isOverriddenByMutationB = Object.entries(mutationB.properties).some(([bPropName]) => {
            return aPropName.startsWith(bPropName + '.') && aPropNameDots > bPropName.split('.').length;
        });
        if (isOverriddenByMutationB) {
            delete result.properties[aPropName];
        }
    }
    for (const [bPropName, bPropValues] of sortUpdateMutationProperties(mutationB)) {
        result.properties[bPropName] = [...(result.properties[bPropName] || []), ...bPropValues];
    }
    return result;
}
function applyUpdateMutation(doc, updateMutation) {
    if (!doc)
        return undefined;
    const result = Object.assign({}, doc);
    const entries = sortUpdateMutationProperties(updateMutation);
    for (const [fieldName, propertyMutationsAr] of entries) {
        const propertyMutations = propertyMutationsAr;
        for (const propertyMutation of propertyMutations) {
            const value = applyPropertyMutation((0, object_1.getInPath)(result, fieldName), propertyMutation);
            if (value === undefined) {
                (0, object_1.deleteInPath)(result, fieldName);
            }
            else {
                (0, object_1.setInPath)(result, fieldName, value);
            }
        }
    }
    return result;
}
exports.applyUpdateMutation = applyUpdateMutation;
function convertInsertToUpdate(insertMutation) {
    const result = {
        type: 'update',
        squidDocIdObj: insertMutation.squidDocIdObj,
        properties: {},
    };
    for (const [key, value] of Object.entries(insertMutation.properties)) {
        result.properties[key] = [{ type: 'update', value }];
    }
    return result;
}
exports.convertInsertToUpdate = convertInsertToUpdate;
/**
 * Reduces the list of mutations such that each document will have a single mutation. If for example there are multiple
 * updates to the same document, those will be merged and a single update will be returned.
 */
function reduceMutations(mutations) {
    let result = [];
    (0, rxjs_1.from)(mutations)
        .pipe((0, rxjs_1.groupBy)((mutation) => {
        return `${mutation.squidDocIdObj.integrationId}${mutation.squidDocIdObj.collectionName}/${mutation.squidDocIdObj.docId}`;
    }), (0, rxjs_1.mergeMap)((mutationsGroup) => mutationsGroup.pipe((0, rxjs_1.reduce)((mutationA, mutationB) => {
        return mergeMutations(mutationA, mutationB);
    }))), (0, rxjs_1.toArray)())
        .subscribe((value) => {
        result = value;
    });
    return result;
}
exports.reduceMutations = reduceMutations;
//# sourceMappingURL=mutation.types.js.map