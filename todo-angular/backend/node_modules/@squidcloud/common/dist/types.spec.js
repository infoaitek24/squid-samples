"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class TypeAssertions {
    assertValid(s) {
        return;
    }
    assertInvalid(s) {
        return;
    }
}
describe('The Path type', () => {
    it('works with simple object', () => {
        const { assertValid, assertInvalid } = new TypeAssertions();
        assertValid('a');
        assertInvalid('a.b');
    });
    it('works with complex object', () => {
        const { assertValid, assertInvalid } = new TypeAssertions();
        assertValid('a');
        assertInvalid('a.b');
        assertValid('b');
        assertValid('b.c');
        assertValid('b.d');
        assertInvalid('b.e');
        assertValid('b.d.e');
        assertValid('b.f');
        assertInvalid('b.f.k');
        assertInvalid('c');
        assertInvalid('d');
        assertInvalid('d.e');
        assertValid('g');
        assertValid('g.h');
        assertValid('i');
        // Array indexes are not supported
        assertInvalid('i.0');
        assertInvalid('i.42');
        assertInvalid('i.42.o');
        assertValid('j');
        assertInvalid('j.k');
        assertValid('l');
        assertValid('l');
        assertValid('l.a');
        assertValid('l.l');
        assertValid('l.l.l');
        assertValid('l.l.l');
        assertValid('l.l.l.l');
        assertValid('l.l.l.l.l');
        // Too much nesting means you can do anything. The fourth level can't be invalid, but at the fifth you're on your
        // own.
        assertInvalid('l.l.l.l.q');
        assertValid('l.l.l.l.l.q');
    });
});
//# sourceMappingURL=types.spec.js.map