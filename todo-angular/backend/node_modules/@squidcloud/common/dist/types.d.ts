export interface Type<T> extends Function {
    new (...args: any[]): T;
}
export type Replace<TypeToBeChecked, KeyToBeReplaced extends keyof TypeToBeChecked, NewValueToUse> = Omit<TypeToBeChecked, KeyToBeReplaced> & {
    [P in KeyToBeReplaced]: NewValueToUse;
};
export type PartialBy<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;
export type WithRequired<T, K extends keyof T> = T & {
    [P in K]-?: T[P];
};
type Pred = [0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
export type Paths<T, RemainingDepth extends number & keyof Pred = 5, Prefix extends string = ''> = RemainingDepth extends 0 ? `${Prefix}${string}` : {
    [k in keyof T]-?: k extends string | number ? `${Prefix}${k}` | (Required<T>[k] extends any[] ? never : Required<T>[k] extends object ? Paths<Required<T>[k], Pred[RemainingDepth], `${Prefix}${k}.`> : never) : never;
}[keyof T];
export {};
