import { ClientId, IntegrationId } from './communication.types';
import { DocTimestamp, FieldName, SquidDocId, SquidDocIdObj, SquidDocument } from './document.types';
export interface MutateRequest<T = any> {
    clientId: ClientId;
    integrationId: IntegrationId;
    mutations: Array<Mutation<T>>;
}
export interface ExecuteMutationsResponse {
    timestamp: DocTimestamp;
    idResolutionMap?: IdResolutionMap;
    afterDocs: Record<SquidDocId, SquidDocument>;
}
export interface MutateResponse extends Omit<ExecuteMutationsResponse, 'afterDocs'> {
    refreshList: Array<SquidDocId>;
}
export type IdResolutionMap = Record<SquidDocId, SquidDocId>;
export type Mutation<T = any> = UpdateMutation<T> | InsertMutation<T> | DeleteMutation;
export type MutationType = 'insert' | 'update' | 'delete';
interface BaseMutation {
    type: MutationType;
    squidDocIdObj: SquidDocIdObj;
}
export interface DeleteMutation extends BaseMutation {
    type: 'delete';
}
export interface UpdateMutation<T = any> extends BaseMutation {
    type: 'update';
    properties: {
        [key in keyof T & string]?: Array<PropertyMutation<T[key]>>;
    };
}
export interface InsertMutation<T = any> extends BaseMutation {
    type: 'insert';
    properties: T;
}
export type PropertyMutation<Value = any> = ApplyNumericFnPropertyMutation | ApplyStringFnPropertyMutation | ValueUpdatePropertyMutation<Value> | RemovePropertyMutation;
export interface ValueUpdatePropertyMutation<Value = any> {
    type: 'update';
    value: Value;
}
export interface ApplyNumericFnPropertyMutation {
    type: 'applyNumericFn';
    fn: 'increment';
    value: number;
}
export interface RemovePropertyMutation {
    type: 'removeProperty';
}
interface ApplyExtendString {
    type: 'applyStringFn';
    fn: 'extendString';
    value: string;
}
interface ApplyTrimString {
    type: 'applyStringFn';
    fn: 'trim';
}
export type ApplyStringFnPropertyMutation = ApplyExtendString | ApplyTrimString;
/**
 * Sorts the update mutation properties in the order the properties should be applied. If the update mutation has
 * updates for both 'a' and 'a.b', the update should be applied first to 'a' and then to 'a.b'.
 */
export declare function sortUpdateMutationProperties(updateMutation: UpdateMutation): Array<[FieldName, Array<PropertyMutation>]>;
export declare function mergeMutations(mutationA: Mutation, mutationB: Mutation): Mutation;
export declare function applyUpdateMutation<T extends SquidDocument>(doc: T, updateMutation: UpdateMutation<T>): T | undefined;
export declare function convertInsertToUpdate(insertMutation: InsertMutation): UpdateMutation;
/**
 * Reduces the list of mutations such that each document will have a single mutation. If for example there are multiple
 * updates to the same document, those will be merged and a single update will be returned.
 */
export declare function reduceMutations(mutations: Array<Mutation<unknown>>): Array<Mutation<unknown>>;
export {};
