"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SimpleQueryBuilder = void 0;
const tslib_1 = require("tslib");
const _ = tslib_1.__importStar(require("lodash"));
const assert_1 = require("../utils/assert");
const validation_1 = require("../utils/validation");
class SimpleQueryBuilder {
    constructor(collectionName, integrationId) {
        this.collectionName = collectionName;
        this.integrationId = integrationId;
        this.query = {
            integrationId,
            collectionName,
            conditions: [],
            limit: -1,
            sortOrder: [],
        };
    }
    where(fieldName, operator, value) {
        if (operator === 'in' || operator === 'not in') {
            const values = value instanceof Array ? [...value] : [value];
            for (const value of values) {
                this.query.conditions.push({
                    fieldName,
                    operator: operator === 'in' ? '==' : '!=',
                    value: value,
                });
            }
            return this;
        }
        this.query.conditions.push({
            fieldName,
            operator,
            value: value,
        });
        return this;
    }
    limit(limit) {
        (0, validation_1.validateQueryLimit)(limit);
        (0, assert_1.assertTruthy)(this.query.limit === -1, 'The limit was already set.');
        this.query.limit = limit;
        return this;
    }
    sortBy(fieldName, asc = true) {
        const fieldSort = { asc, fieldName };
        (0, validation_1.validateFieldSort)(fieldSort);
        (0, assert_1.assertTruthy)(!this.query.sortOrder.some((so) => so.fieldName === fieldName), `${fieldName} already in the sort list.`);
        this.query.sortOrder.push(fieldSort);
        return this;
    }
    build() {
        const mergedConditions = this.mergeConditions();
        return Object.assign(Object.assign({}, this.query), { conditions: mergedConditions });
    }
    mergeConditions() {
        const result = [];
        const groupByFieldName = _.groupBy(this.query.conditions || [], (condition) => condition.fieldName);
        for (const fieldNameGroup of Object.values(groupByFieldName)) {
            const groupByOperator = _.groupBy(fieldNameGroup, (operator) => operator.operator);
            for (const [operator, operatorGroup] of Object.entries(groupByOperator)) {
                if (operator === '==' || operator === '!=') {
                    result.push(...operatorGroup);
                    continue;
                }
                const sorted = _.sortBy(operatorGroup, (o) => o.value);
                if (operator === '>' || operator === '>=') {
                    result.push(sorted[sorted.length - 1]);
                }
                else if (operator === '<' || operator === '<=') {
                    result.push(sorted[0]);
                }
                else {
                    throw new Error(`Unsupported operator ${operator}`);
                }
            }
        }
        return result;
    }
}
exports.SimpleQueryBuilder = SimpleQueryBuilder;
//# sourceMappingURL=simple-query-builder.js.map