"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.QueryContext = void 0;
const lodash_1 = require("lodash");
/**
 * The compare table is used to determine whether one condition (conditionA)
 * is a subset of another condition (conditionB).
 *
 * The keys to the table are in the form of ${conditionA.operator}:${conditionB.operator},
 * and the return values are functions, that when passed (conditionA.value, conditionB.value)
 * will return whether conditionA is a subset of conditionB.
 *
 * The following example:
 *   '==:==': (a, b) => a === b,
 * Can be read as:
 *   ("x", "==", a) is a subset of ("x", "==", b) when a === b
 */
const CompareTable = {
    'in:in': (a, b) => a.every((c) => b.includes(c)),
    'in:not in': (a, b) => a.every((c) => !b.includes(c)),
    'not in:not in': (a, b) => b.every((c) => a.includes(c)),
    '>:not in': (a, b) => b.every((c) => a >= c),
    '>=:not in': (a, b) => b.every((c) => a > c),
    '<:not in': (a, b) => b.every((c) => a <= c),
    '<=:not in': (a, b) => b.every((c) => a < c),
    '>:>': (a, b) => a >= b,
    '>=:>': (a, b) => a > b,
    'in:>': (a, b) => a.every((c) => c > b),
    '>:>=': (a, b) => a >= b,
    '>=:>=': (a, b) => a >= b,
    'in:>=': (a, b) => a.every((c) => c >= b),
    '<:<': (a, b) => a <= b,
    '<=:<': (a, b) => a < b,
    'in:<': (a, b) => a.every((c) => c < b),
    '<:<=': (a, b) => a <= b,
    '<=:<=': (a, b) => a <= b,
    'in:<=': (a, b) => a.every((c) => c <= b),
};
class QueryContext {
    constructor(query) {
        this.query = query;
        this.query = query;
        this.parsedConditions = this.parseConditions(this.query.conditions);
    }
    get integrationId() {
        return this.query.integrationId;
    }
    get collectionName() {
        return this.query.collectionName;
    }
    get limit() {
        return this.query.limit;
    }
    sortedBy(sorts) {
        const mismatch = sorts.find((fieldSort, index) => {
            var _a;
            return !(0, lodash_1.isEqual)(this.query.sortOrder[index], Object.assign(Object.assign({}, fieldSort), { asc: (_a = fieldSort.asc) !== null && _a !== void 0 ? _a : true }));
        });
        return !mismatch;
    }
    sortedByExact(sorts) {
        if (sorts.length !== this.query.sortOrder.length)
            return false;
        return this.sortedBy(sorts);
    }
    // Includes
    includes(fieldName, operator, value) {
        return this.includesCondition({ fieldName, operator, value });
    }
    includesCondition(condition) {
        const conditions = this.parsedConditions.filter((c) => c.fieldName === condition.fieldName);
        if (!conditions.length)
            return false;
        return !!conditions.find((c) => this.evaluateIncludes(c, condition));
    }
    includesConditions(conditions) {
        const parsedConditions = this.parseConditions(conditions);
        return parsedConditions.every((c) => this.includesCondition(c));
    }
    // Matches
    matchesConditions(conditions) {
        const parsedConditions = this.parseConditions(conditions);
        if (this.parsedConditions.length !== parsedConditions.length)
            return false;
        return parsedConditions.every((c) => this.includesCondition(c));
    }
    matchesQuery(query) {
        if (query.collectionName !== this.collectionName || query.integrationId !== this.integrationId)
            return false;
        const matchesConditions = this.matchesConditions(query.conditions);
        const matchesOrder = this.sortedByExact(query.sortOrder);
        const matchesLimit = this.limit === query.limit;
        return matchesConditions && matchesOrder && matchesLimit;
    }
    // Subsets
    isSubsetOf(fieldName, operator, value) {
        return this.isSubsetOfCondition({
            fieldName,
            operator,
            value,
        });
    }
    isSubsetOfCondition(condition) {
        const conditions = this.parsedConditions.filter((c) => c.fieldName === condition.fieldName);
        return !!conditions.find((c) => this.evaluateSubset(c, condition));
    }
    isSubsetOfConditions(conditions) {
        const parsedConditions = this.parseConditions(conditions);
        return parsedConditions.every((c) => this.isSubsetOfCondition(c));
    }
    isSubsetOfQuery(query) {
        if (query.collectionName !== this.collectionName || query.integrationId !== this.integrationId)
            return false;
        const subsetOfConditions = this.isSubsetOfConditions(query.conditions);
        const subsetOfOrder = this.sortedBy(query.sortOrder);
        const withinLimit = query.limit === -1 || (this.limit > -1 && this.limit < query.limit);
        return subsetOfConditions && subsetOfOrder && withinLimit;
    }
    getConditionsFor(...fieldNames) {
        return this.parsedConditions.filter((cond) => fieldNames.includes(cond.fieldName));
    }
    getConditionsForField(fieldName) {
        return this.parsedConditions.filter((cond) => cond.fieldName === fieldName);
    }
    /**
     * Compares a condition against a given operator and value to determine if the
     * provided condition is a subset of the operator and value. A condition is
     * considered a subset if all values that satisfy (return true for) the
     * condition also satisfy the operator and value.
     *
     * This is done using the underlying CompareTable, which provides a comparison
     * function for each operator pair, or undefined if the comparison would
     * always be false, regardless of the values.
     */
    evaluateSubset(queryCondition, testCondition) {
        const { operator: queryOperator, value: queryValue } = queryCondition;
        const { operator, value } = this.parseConditions([testCondition])[0];
        const compareFunction = CompareTable[`${queryOperator}:${operator}`];
        if (!compareFunction)
            return false;
        return compareFunction(queryValue, value);
    }
    evaluateIncludes(queryCondition, testCondition) {
        const { operator: queryOperator, value: queryValue } = queryCondition;
        const { operator, value } = this.parseConditions([testCondition])[0];
        const sortedQueryValue = Array.isArray(queryValue) ? queryValue.sort() : queryValue;
        const sortedValue = Array.isArray(value) ? value.sort() : value;
        return operator === queryOperator && (0, lodash_1.isEqual)(sortedValue, sortedQueryValue);
    }
    parseConditions(conditions) {
        const parsedConditions = [];
        const inMap = new Map();
        const notInMap = new Map();
        conditions.forEach((c) => {
            switch (c.operator) {
                case '==':
                case 'in':
                    inMap.set(c.fieldName, (inMap.get(c.fieldName) || []).concat(c.value));
                    break;
                case '!=':
                case 'not in':
                    notInMap.set(c.fieldName, (notInMap.get(c.fieldName) || []).concat(c.value));
                    break;
                default:
                    parsedConditions.push(c);
                    break;
            }
        });
        inMap.forEach((value, fieldName) => {
            parsedConditions.push({
                fieldName,
                operator: 'in',
                value: value,
            });
        });
        notInMap.forEach((value, fieldName) => {
            parsedConditions.push({
                fieldName,
                operator: 'not in',
                value: value,
            });
        });
        return parsedConditions;
    }
}
exports.QueryContext = QueryContext;
//# sourceMappingURL=query-context.js.map